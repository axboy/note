# 设计模式

主要了解思路，无需记住。工作中是有这个思路去解决问题，而不是特意去用什么模式。
学习的最终目的是思维的训练。

策略模式，简言之，就是封装了行为，因为行为在变化。 
状态模式，就是封装了状态，因为状态在变化。 
命令模式，就是封装了命令，因为命令在变化。 
观察者模式，封装了观察者和被观察者，因为需要感知变化的观察者在变化。 
迭代器模式，封装了容器，因为容器在变化。 

## 创建型

- 工厂模式

定义创建对象的接口，由子类决定如何实例化

- 抽象工厂

- 建造者模式

将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

- 单例

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

- 原型

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

## 结构型

- 适配器

将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

- 桥接模式

将抽象部分与实现部分分离，使它们都可以独立的变化。
实现系统可能有多个角度分类，每一种角度都可能变化。

- 装饰器模式

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。侧重于增加功能。

- 代理模式

为其他对象提供一种代理以控制对这个对象的访问。侧重于控制。

- 外观模式

外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。

## 行为型

- 责任链

避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。